package org.jorion.euler.problem;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.jorion.euler.util.MathUtils;
import org.jorion.euler.util.PrimeUtils;
import org.jorion.euler.util.Utils;

/**
 * Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5 :
 *
 * <table border=1>
 * <tr>
 * <td>2^2=4</td>
 * <td>2^3=8</td>
 * <td>2^4=16 <b>(1)</b></td>
 * <td>2^5=32</td>
 * <td>2^6=64 <b>(2)</b></td>
 * <td>2^7=128</td>
 * <td>2^8=256 <b>(3)</b></td>
 * <td>2^9=512 <b>(4)</b></td>
 * <td>2^10=1024 <b>(5)</b></td>
 * </tr>
 * <tr>
 * <td>3^2=9</td>
 * <td>3^3=27</td>
 * <td>3^4=81 <b>(6)</b></td>
 * <td>3^5=243</td>
 * <td>3^6=729 <b>(7)</b></td>
 * <td>3^7=2187</td>
 * <td>3^8=6561 <b>(8)</b></td>
 * <td>3^9=19683</td>
 * <td>3^10=59049 <b>(9)</b></td>
 * </tr>
 * <tr>
 * <td>4^2=16 <b>(1)</b></td>
 * <td>4^3=64 <b>(2)</b></td>
 * <td>4^4=256 <b>(3)</b></td>
 * <td>4^5=1024 <b>(4)</b></td>
 * <td>4^6=4096 <b>(A)</b></td>
 * <td>4^7=16384</td>
 * <td>4^8=65536</td>
 * <td>4^9=262144 <b>(B)</b></td>
 * <td>4^10=1048576</td>
 * </tr>
 * <tr>
 * <td>5^2=25</td>
 * <td>...</td
 * </tr>
 * <tr>
 * <td>6^2=36</td>
 * <td>6^3=216</td>
 * <td>6^4=1296</td>
 * <td>6^5=7776</td>
 * <td>6^6=46656</td>
 * <td>6^7=279936</td>
 * <td>6^8=1679616</td>
 * <td>6^9=10077696</td>
 * <td>6^10=60466176</td>
 * </tr>
 * <tr>
 * <td>7^2=49</td>
 * <td>...</td>
 * </tr>
 * <tr>
 * <td>8^2=64 <b>(2)</b></td>
 * <td>8^3=512 <b>(4)</b></td>
 * <td>8^4=4096 <b>(a)</b></td>
 * <td>8^5=32768</td>
 * <td>8^6=262144 <b>(b)</b></td>
 * <td>8^7=2097152</td>
 * <td>8^8=16777216</td>
 * <td>8^9=134217728</td>
 * <td>8^10=1073741824</td>
 * </tr>
 * <tr>
 * <td>9^2=81 <b>(6)</b></td>
 * <td>9^3=729 <b>(7)</b></td>
 * <td>9^4=6561 <b>(8)</b></td>
 * <td>9^5=59049 <b>(9)</b></td>
 * <td>9^6=531441</td>
 * </tr>
 * <tr>
 * <td>10^2=100</td>
 * <td>...</td>
 * </tr>
 * <table>
 *
 * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct
 * terms:
 *
 * <pre>
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 * </pre>
 *
 * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 */
public class Euler029 {
	// --- Methods ---
	public static void main(String[] args) {
		// 36: 1085
		final int max = 100;
		long res; // 9183
		long delta;

		Utils.start();
		res = calc0(max);
		delta = Utils.stop();
		Utils.print("Brute     ", res, delta);

		Utils.start();
		res = calc1(max);
		delta = Utils.stop();
		Utils.print("Algorithm ", res, delta);
	}

	/**
	 * Use BigInteger.
	 */
	private static long calc0(int max) {
		Set<BigInteger> set = new TreeSet<>();
		for (int a = 2; a <= max; a++) {
			for (int b = 2; b <= max; b++) {
				BigInteger aa = new BigInteger(Integer.toString(a));
				BigInteger val = aa.pow(b);
				set.add(val);
			}
		}
		// set.stream().forEach(System.out::println);
		return set.size();
	}

	private static long calc1(int max) {
		int sum = 0;
		boolean[] primes = PrimeUtils.isPrimeSoE(max);
		Map<Integer, List<Integer>> mul = new TreeMap<>();
		for (int a = 2; a <= max; a++) {
			sum += (max - 1);
			// prime
			if (primes[a]) {
				List<Integer> list = new ArrayList<>();
				for (int b = 2; b <= max; b++) {
					list.add(b);
				}
				mul.put(a, list);
				continue;
			}
			// composite
			// decompose a number into a map where the key = its prime factor and value = the number of prime occurences
			// ex: 36 = 2^2*3^2 = 6^4; 72 = 2^3*3^2 = 8*9;
			Map<Integer, Integer> factors = PrimeUtils.findPrimeFactors(a, primes);

			// find the gcd of all exponents
			int gcd = 0;
			for (int prime : factors.keySet()) {
				int exp = factors.get(prime);
				// note: I cannot guarantee this will work in all cases
				gcd = (gcd == 0) ? exp : MathUtils.gcd(gcd, exp);
			}

			// find the product of primes (base) such as base^gcd=a
			// ex: 36=2^2*3^2=6^2; 72=2^3*3^2=72^1
			int base = 1;
			for (int prime : factors.keySet()) {
				int exp = factors.get(prime);
				for (int i = 1; i <= exp / gcd; i++) {
					base = base * prime;
				}
			}

			List<Integer> list = mul.get(base);
			if (list == null) {
				// System.out.println("List not found for value: " + base + ", a: " + a + ", gcd: " + gcd);
				list = new ArrayList<>();
				mul.put(base, list);
			}
			for (int b = 2; b <= max; b++) {
				int val = gcd * b;
				// if the value already exists in the list, remove it from the count
				if (list.contains(val)) {
					// print("---", a, b, base, val);
					sum--;
				} else {
					list.add(val);
				}
			}
		}
		return sum;
	}

	@SuppressWarnings("unused")
	private static void print(String msg, int a, int b, int base, int val) {
		System.out.println(msg + " " + a + "): a^b = " + a + "^" + b + " = " + base + "^" + val);
	}
}
