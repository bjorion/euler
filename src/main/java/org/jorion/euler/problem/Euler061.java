package org.jorion.euler.problem;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.jorion.euler.util.Utils;

/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and
 * are generated by the following formulae:
 * <ul>
 * <li>Triangle => P3,n = n(n+1)/2 => 1, 3, 6, 10, 15, ...
 * <li>Square => P4,n = n2 => 1, 4, 9, 16, 25, ...
 * <li>Pentagonal => P5,n = n(3n−1)/2 => 1, 5, 12, 22, 35, ...
 * <li>Hexagonal => P6,n = n(2n−1) => 1, 6, 15, 28, 45, ...
 * <li>Heptagonal => P7,n = n(5n−3)/2 => 1, 7, 18, 34, 55, ...
 * <li>Octagonal => P8,n = n(3n−2) => 1, 8, 21, 40, 65, ...
 * </ul>
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 * <ol>
 * <li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number
 * (including the last number with the first).
 * <li>Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by
 * a different number in the set.
 * <li>This is the only set of 4-digit numbers with this property.
 * </ol>
 * Find the sum of the only ordered set of <b>six</b> cyclic 4-digit numbers for which each polygonal type: triangle,
 * square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 */
public class Euler061
{
    private static final int start = 3;

    private static final int end = 8 + 1;

    // --- Methods ---
    public static void main(String[] args)
    {
        long res;
        long delta;

        Utils.start();
        res = calc1();
        delta = Utils.stop();
        Utils.print("Algorithm ", res, delta);
    }

    /**
     * In this algorithm, we first compute all possible polygonal numbers (3 to 8) with four digits [1000,10000[.
     * <p>
     * We also make the hypothesis that for a given value (3 to 8), there are NO two polygonal numbers starting with
     * both the same two digits.
     * <p>
     * Note: the hypothesis above is actually NOT true (for 3 to 5), but very few numbers are concerned, and there are
     * not part of the solution.
     * <p>
     * We do not check the condition that all numbers in the set are different because that's unlikely.
     */
    private static long calc1()
    {
        final int min = 1000;
        final int max = 10000;

        // initialize
        List<List<Integer>> m = new ArrayList<>();
        for (int k = 0; k < end; k++) {
            List<Integer> list = new ArrayList<Integer>();
            int n = 1;
            while (k >= start) {
                int p = pkn(k, n);
                if (p >= max) {
                    break;
                }
                if (p >= min) {
                    list.add(p);
                }
                n++;
            }
            m.add(list);
        }

        boolean[] arr = new boolean[end];
        arr[start] = true;

        List<Integer> solutions = new ArrayList<>();
        List<Integer> list = m.get(start);
        for (Integer first : list) {
            LinkedList<Integer> values = new LinkedList<>();
            values.add(first);
            f(m, arr, values, 1, solutions);
            // we stop at the first solution found
            if (!solutions.isEmpty()) {
                break;
            }
        }

        // solutions.stream().forEach(System.out::println);
        int res = solutions.stream().reduce(0, Integer::sum);
        return res;
    }

    /**
     * Recursive function.
     *
     * @param m the list of all polygonal values
     * @param arr an array whose element is true if it was tested, false otherwise
     * @param values the list of matching values found until now
     * @param level the depth of the recursion (to know when we must stop)
     * @param solutions if not empty, a list with the solution values
     */
    private static void f(List<List<Integer>> m, boolean[] arr, LinkedList<Integer> values, int level, List<Integer> solutions)
    {
        // end of the recursion
        if (level == (end - start)) {
            int last = values.getLast();
            int first = values.getFirst();
            if (last % 100 == first / 100) {
                solutions.clear();
                solutions.addAll(values);
            }
            return;
        }

        // find first "null" value
        for (int i = start + 1; i < end; i++) {
            if (arr[i]) {
                continue;
            }

            // here we might want to loop on all possible matching numbers instead of taking
            // only the first one
            int res = findNext(m, i, values.getLast());
            if (res < 0) {
                continue;
            }

            // a matching number was found for this index, so we continue to the next level
            boolean[] newArr = Arrays.copyOf(arr, end);
            newArr[i] = true;
            values.addLast(res);
            f(m, newArr, values, level + 1, solutions);
            values.removeLast();
        }
        return;
    }

    /**
     * Retrieve the FIRST number starting with the last two digits of val.
     */
    private static int findNext(List<List<Integer>> m, int k, int val)
    {
        int res = -1;
        int base = val % 100;
        // we ignore one-digit base (meaning no base can start with zero)
        if (base < 10) {
            return res;
        }

        int min = base * 100;
        int max = (base + 1) * 100;
        List<Integer> list = m.get(k);
        Iterator<Integer> iter = list.iterator();
        while (iter.hasNext()) {
            int n = iter.next();
            if (n >= max) {
                break;
            }
            if (n >= min) {
                res = n;
                break;
            }
        }
        return res;
    }

    private static int pkn(int k, int n)
    {
        int res = 0;
        switch (k) {
        case 3:
            res = n * (n + 1) / 2;
            break;
        case 4:
            res = n * n;
            break;
        case 5:
            res = n * (3 * n - 1) / 2;
            break;
        case 6:
            res = n * (2 * n - 1);
            break;
        case 7:
            res = n * (5 * n - 3) / 2;
            break;
        case 8:
            res = n * (3 * n - 2);
            break;
        default:
            throw new IllegalArgumentException("k: " + k + ", n: " + n);
        }
        return res;
    }

}